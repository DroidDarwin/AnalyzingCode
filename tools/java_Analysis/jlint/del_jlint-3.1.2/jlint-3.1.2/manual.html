<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on January, 11  2011 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>Jlint manual: </TITLE>

<META NAME="description" CONTENT="Jlint manual: ">
<META NAME="keywords" CONTENT="Jlint manual: ">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC_Top"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1>Jlint manual</H1></P><P>

This document described Jlint, a Java program checker that will check your Java code and find bugs, inconsistencies and synchronization problems by doing data flow analysis and building a lock graph.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual.html#SEC1">1. Introduction</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual.html#SEC2">2. Bugs detected by AntiC</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Overview of AntiC.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual.html#SEC25">3. Bugs detected by Jlint</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Overview of Jlint.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual.html#SEC62">4. Command line options</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Usage of antic and jlint.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual.html#SEC66">5. How to build and use Jlint and AntiC</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Information about the Makefile.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual.html#SEC67">6. Release notes</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<HR SIZE=1>
<A NAME="SEC1"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[ &lt;&lt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<A NAME="Introduction"></A>
</P><P>

<H1> 1. Introduction </H1>
<!--docid::SEC1::-->
Jlint will check your Java code and find bugs, inconsistencies
and synchronization problems by doing data flow analysis and building
lock graph.
<P>

Jlint consists of two separate programs performing syntax and semantic 
verification. As far as Java mostly inherits C/C++ syntax and so 
inherits most of the problems caused by C syntax, the idea was
to create common syntax verifier for all C-family languages:
C, C++, Objective C and Java. This program was named <STRONG><EM>AntiC</EM></STRONG>,
because it fixes problems with C grammar, which can cause dangerous
programmer's bugs, undetected by compiler. By using hand-written scanner
and simple top-down parser, AntiC is able to detect such bugs as 
suspicious use of operators priorities, absence of break in switch 
code, wrong assumption about constructions bodies...
</P><P>

Semantic verifier Jlint extracts information from Java class files. 
As far as Java class file has very well specified and simple format,
it greatly simplifies Jlint in comparison with source level verifiers, 
because development of Java grammar parser is not a simple task
(even through Java grammar is simpler and less ambiguous than C++ grammar).
Also dealing only with class files, protect Jlint from further Java extensions
(format of virtual byte instructions is more conservative). By using
debugging information Jlint can associate reported messages with Java sources.
</P><P>

Jlint performs local and global data flow analyses, calculating possible
values of local variables and catching redundant and suspicious
calculations. By performing global method invocation analysis, 
Jlint is able to detect invocation of method with possible "null"
value of formal parameter and using of this parameter in method
without check for "null". Jlint also builds lock dependency graph for classes 
dependencies and uses
this graph to detect situations, which can cause <EM>deadlock</EM> during 
multi-threaded program execution. Except deadlocks, Jlint is able
to detect possible <EM>race condition</EM> problem, when different threads
can concurrently access the same variables.
Certainly Jlint can't catch all synchronization problems, but at least it
can do something, which can save you a lot of time, because 
synchronization bugs are the most dangerous bugs: non-deterministic,
and not always reproducible. Unfortunately Java compiler can't help
you with detecting synchronization bugs, may be Jlint can...
</P><P>

Jlint uses smart approach to message reporting. All messages are 
grouped in categories, and it is possible to enable or disable reporting
messages of specific category as well as concrete messages. Jlint can remember
reported messages and do not report them once again when you run Jlint second
time. This feature is implemented by means of history file. If you 
specify <VAR>-history</VAR> option, then before reporting
a message, Jlint searches in this file if such message was already 
reported in the past. If so, then no message is reported and programmer will 
not have to spend time parsing the same messages several times. 
If message was not found in history file, it is reported and appended
to history file to eliminate reporting of this message in future.
Some messages refer to class/method name and are position independent,
while some messages are reported for specific statement in method's code.
Messages of second type will not be repeatedly reported only if
method's source is not changed.
</P><P>

<A NAME="Bugs detected by AntiC"></A>
</P><P>

<HR SIZE="6">
<A NAME="SEC2"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC1"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC3"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[ &lt;&lt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 2. Bugs detected by AntiC </H1>
<!--docid::SEC2::-->
<P>

Input of AntiC should be valid C/C++ or Java program with no syntax errors.
If there are some syntax errors in the program, AntiC can detect some of them
and produce error message, but it doesn't try to perform full syntax checking 
and can't recover after some errors. So in this chapter we discuss only the
messages produced by AntiC for program without syntax errors. 
</P><P>

<A NAME="Bugs in tokens"></A>
<HR SIZE="6">
<A NAME="SEC3"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC4"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC1"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 2.1 Bugs in tokens </H2>
<!--docid::SEC3::-->
<HR SIZE="6">
<A NAME="SEC4"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC3"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC5"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC1"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.1.1 Octal digit expected </H3>
<!--docid::SEC4::-->
Sequence of digits in string or character constant preceded by '\\'
character contains non-octal digit:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>     printf("\128");    
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC5"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC4"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC6"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC6"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.1.2 May be more than three octal digits are specified </H3>
<!--docid::SEC5::-->
Sequence of digits in string or character constant preceded by '\\'
character contains more than three digits:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    printf("\1234");    
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC6"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC5"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC7"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC7"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.1.3 May be more than four hex digits are </H3>
<!--docid::SEC6::-->
specified for character constant
<P>

String constant contains escape sequence for Unicode character, 
followed by character, which can be treated as hexadecimal digit:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    System.out.println("\uABCDE:");     
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC7"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC6"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC8"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC8"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.1.4 May be incorrect escape sequence </H3>
<!--docid::SEC7::-->
<P>

Non-standard escape sequence is used in character or string constant:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    printf("\x");       
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC8"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC7"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC9"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC9"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.1.5 Trigraph sequence inside string </H3>
<!--docid::SEC8::-->
Some C/C++ compilers still support trigraph sequences of ANSI C and replace
the following sequences of characters 
("??=", "??/", "??'", "??(", "??)", "??!", "??") 
with the characters 
("#", "\", "^", "[", "]", "|", "{", "}") 
respectively. This feature may cause unexpected transformation of string 
constants:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    char* p = "???=undefined";
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC9"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC8"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC10"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC10"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.1.6 Multi-byte character constants are not portable </H3>
<!--docid::SEC9::-->
<P>

Multi-byte character constants are possible in C, but makes program non-portable.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    char ch = 'ab';
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC10"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC9"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC11"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC1"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.1.7 May be 'l' is used instead of '1' at the end of integer constant </H3>
<!--docid::SEC10::-->
<P>

It is difficult to distinct lower case letter 'l' and digit '1'. As far as 
letter 'l' can be used as long modifier at the end of integer constant, 
it can be mixed with digit. It is better to use upper-case 'L':
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    long l = 0x111111l;
</pre></td></tr></table></P><P>

<A NAME="Operators priorities"></A>
</P><P>

<HR SIZE="6">
<A NAME="SEC11"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC10"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC12"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC3"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC18"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 2.2 Operator priorities </H2>
<!--docid::SEC11::-->
<P>

<HR SIZE="6">
<A NAME="SEC12"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC11"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC13"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC1"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.2.1 May be wrong assumption about operators precedence </H3>
<!--docid::SEC12::-->
<P>

Several operators with non-intuitive clear precedence are used without
explicit grouping by parentheses. Sometimes programmer's assumption about 
operators priorities is not true, and in any case enclosing such operations in 
parentheses can only increase readability of program. Below is list of some
suspicious combinations of operators:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    x &#38; y == z
    x &#38;&#38; y &#38; z
    x || y = z
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC13"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC12"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC14"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC14"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.2.2 May be wrong assumption about logical operators precedence </H3>
<!--docid::SEC13::-->
<P>

Priority of logical AND operator is higher than priority of logical OR 
operator. So AND expression will be evaluated before OR expression even
if OR precedes AND:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    x || y &#38;&#38; z 
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC14"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC13"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC15"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC15"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.2.3 May be wrong assumption about shift operator priority </H3>
<!--docid::SEC14::-->
<P>

Priority of shift is smaller than of arithmetic operators but less than 
of bit manipulation operators. It can cause wrong assumption about operands 
grouping:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    x&#62;&#62;y - 1
    x &#62;&#62; y&#38;7
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC15"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC14"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC16"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC16"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.2.4 May be '=' used instead of '==' </H3>
<!--docid::SEC15::-->
<P>

Almost all C programmer did this bug, at least once in their life. 
It very easy to type '=' instead of '==' and not all C compilers
can detect this situation. Moreover this bug is inherited by Java:
the only restriction is that types of operands should be boolean:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    if (x = y) {}
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC16"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC15"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC17"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC17"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.2.5 May be skipped parentheses around assign operator </H3>
<!--docid::SEC16::-->
<P>

Assign operators have one of the smallest priorities. So if you want to test
result of assignment operation, you should enclose it in parentheses:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    if (x&#62;&#62;=1 != 0) {}
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC17"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC16"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC18"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC1"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.2.6 May be wrong assumption about bit operation priority </H3>
<!--docid::SEC17::-->
<P>

Bit manipulation operators have smaller priority than compare operators.
If you, for example, extracting bits using bit AND operator, do not
forget to enclose it with parentheses, otherwise result of the expression
will be far from your expectation:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    if (x == y &#38; 1) {}
</pre></td></tr></table></P><P>

<A NAME="Statement body"></A>
</P><P>

<HR SIZE="6">
<A NAME="SEC18"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC17"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC19"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[ &lt;&lt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 2.3 Statement body </H2>
<!--docid::SEC18::-->
<P>

Almost all C statements can contain as its sub-part either single statement or
block of statements (enclosed by braces). Unnoticed semicolon or wrong 
alignment can confuse programmer about real statement's body. 
And compiler can't produce any warnings, because it deals with stream of 
tokens, without information about code alignment.
</P><P>

<HR SIZE="6">
<A NAME="SEC19"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC18"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC20"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC1"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.3.1 May be wrong assumption about loop body </H3>
<!--docid::SEC19::-->
<P>

This message is produced if loop body is not enclosed in braces and 
indentation of the statement following the loop is bigger than of loop
statement (i.e. it is shifted right):
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>while (x != 0) 
    x &#62;&#62;= 1;
    n += 1;
return x;
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC20"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC19"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC21"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC21"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.3.2 May be wrong assumption about IF body </H3>
<!--docid::SEC20::-->
This message is produced if IF body is not enclosed in braces and indentation 
of the statement following the IF construction is bigger than of IF 
statement itself (i.e. it is shifted right) or IF body is empty statement 
(';'):
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    if (x &#62; y);
    {
        int tmp = x;
        x = y;
        y = tmp; 
    }

    if (x != 0) 
        x = -x; sign = -1;
    sqr = x*x;
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC21"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC20"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC22"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC22"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.3.3 May be wrong assumption about ELSE branch association </H3>
<!--docid::SEC21::-->
<P>

If there are no braces, then ELSE branch belongs to most inner IF. Sometimes 
programmers forget about it: 
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    if (rc != 0) 
        if (perr) *perr = rc;
    else return Ok;
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC22"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC21"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC23"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC23"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.3.4 Suspicious SWITCH without body </H3>
<!--docid::SEC22::-->
<P>

Switch statement body is not a block. With great probability it signals 
about some error in program:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    switch(j) { 
      case 1:
        ...
      case 2:
        switch(ch);  
        {
          case 'a':
          case 'b':
            ...
        }
    }
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC23"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC22"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC24"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC24"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.3.5 Suspicious CASE/DEFAULT </H3>
<!--docid::SEC23::-->
<P>

Case is found  in block not belonging to switch operator. Situations, 
where such possibility can be used are very rare:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    switch (n &#38; 3) {
        do { 
            default:
                *dst++ = 0;
            case 3:
                *dst++ = *drc++;
            case 2:
                *dst++ = *drc++;
            case 1:
                *dst++ = *drc++;
        } while ((n -= 4) &#62; 0;
    }
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC24"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC23"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC1"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.3.6 Possible miss of BREAK before CASE/DEFAULT </H3>
<!--docid::SEC24::-->
<P>

AntiC performs some kind of control flow analysis to detect situations, where
control can be passed from one case branch to another (if programmer
forget about BREAK statement). Sometimes it is necessary to merge 
several branches. AntiC doesn't produce this message in following cases:
</P><P>

<OL>
<LI>Several cases point to the same statement:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>    case '+':
    case '-':
      sign = 1;
      break;
</pre></td></tr></table><LI>Special <CODE>nobreak</CODE> macro is defined and used in switch statement:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    #define nobreak
    ...
    switch (cop) { 
      case sub:
        sp[-1] = -sp[1];
        nobreak;
      case add:
        sp[-2] += sp[-1]; 
        break;
        ...
}
</pre></td></tr></table></P><P>

<LI>Comment containing words "break" or "fall" is placed before the case:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    switch (x) { 
      case do_some_extra_work:
        ...
        // fall thru
      case do_something:
        ...
    }
</pre></td></tr></table></OL>
<P>

In all other cases message is produced when control can be passed from
one switch branch to another:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    switch (action) { 
      case op_remove:
        do_remove(); 
      case op_insert:
        do_insert();
      case op_edit:
        do_edit();
    }
</pre></td></tr></table></P><P>

<A NAME="Bugs detected by Jlint"></A>
</P><P>

<HR SIZE="6">
<A NAME="SEC25"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC24"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC26"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 3. Bugs detected by Jlint </H1>
<!--docid::SEC25::-->
<P>

There are three main groups of messages produced by Jlint:
<STRONG><EM>synchronization, inheritance</EM></STRONG> and <STRONG><EM>data flow</EM></STRONG>. 
These groups are distinguished by kind of analysis which is used
to detect problems, reported in this messages. Each group is in turn divided 
into several categories, which contains one or more messages. 
Such scheme of message classification is used to support
fine-grained selection of reported messages.
</P><P>

Because only categories of message can be disabled, but not separate messages, a short shell script is supplied that will suppress certain warnings that are less important. It should be noted that it will ignore any race conditions for variables. This is because Jlint does not have any notion of "shared reading", so it usually produces too many warnings about such data races to be useful. For some projects, using Jlint's output unfiltered can still be useful.
</P><P>

The shell script is as follows:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>#!/bin/bash
find . -name '*.class' | xargs jlint -not_overridden \
-redundant -weak_cmp -bounds -zero_operand -string_cmp -shadow_local | \
grep -v 'Field .class\$' | grep -v 'can be .*ed from different threads' | \
grep -v 'Method.*Runnable.*synch'

</pre></td></tr></table></P><P>

It is probably more easier to run Jlint using those filters, with
<TABLE><tr><td>&nbsp;</td><td class=example><pre>cd &#60;dir_with_class_files&#62;
jlint.sh
</pre></td></tr></table></P><P>

<A NAME="Synchronization"></A>
</P><P>

<HR SIZE="6">
<A NAME="SEC26"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC27"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC39"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 3.1 Synchronization </H2>
<!--docid::SEC26::-->
<P>

Parallel execution of several threads of control requires some 
synchronization mechanism to avoid access conflicts to shared data. 
Java approach to synchronization is based on using object monitors, controlled
by <CODE>synchronized</CODE> language construction. Monitor is always 
associated with object and prevents concurrent access to the object by using 
mutual exclusion strategy. Java also supports facilities for waiting and 
notification of some condition.
</P><P>

Unfortunately, providing these synchronization primitives, Java compiler
and virtual machine are not able to detect or prevent synchronization problems.
Synchronization bugs are the most difficult bugs, because of non-deterministic
behaviour of multi-threaded program. There are two main sources of 
synchronization problems: deadlocks and race conditions.
</P><P>

Situation in which one or more threads mutually lock each other is called 
deadlock. Usually the reason of deadlock is inconsistent order of 
resource locking by different threads. In Java case resources are object 
monitors and deadlock can be caused by some sequence of method invocations.
Let's look at the following example of multi-threaded database server:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    class DatabaseServer { 
        public TransactionManager transMgr;
        public ClassManager       classMgr;
        ...
    }
    class TransactionManager { 
        protected DatabaseServer server;

        public synchronized void commitTransaction(ObjectDesc[] t_objects) {
            ...
            for (int i = 0; i &#60; t_objects.length; i++) { 
                ClassDesc desc = server.classMgr.getClassInfo(t_objects[i]);
                ...
            }
            ...
        }
        ...
   }
   class ClassManager { 
        protected DatabaseServer server;
           
        public synchronized ClassDesc getClassInfo(ObjectDesc object) { 
            ...
        }
        public synchronized void addClass(ClassDesc desc) { 
            ObjectDesc t_objects;
            ...
            // Organized transaction to insert new class in database
            server.transMgr.commit_transaction(t_objects);
        }
    };
</pre></td></tr></table></P><P>

If database server has one thread for each client and one client is committing
transaction while another client adds new class to database, then deadlock
can arise. Consider the following sequence:
</P><P>

<OL>
<LI>Client A invokes method <CODE>TransactionManager.commitTransaction()</CODE>.
While execution of this method monitor of TransactionManager object is locked.
<P>

<LI>Client B invokes method <CODE>ClassManager.addClass()</CODE> and
locks monitor of ClassManager object.
<P>

<LI>Method <CODE>TransactionManager.commitTransaction()</CODE> tries to invoke
method <CODE>ClassManager.getClassInfo()</CODE> but has to wait because this 
object is locked by another thread.
<P>

<LI>Method <CODE>ClassManager.addClass()</CODE> tries to invoke
method <CODE>TransactionManager.commitTransaction()</CODE> but has to wait 
because this object is locked by another thread.
</OL>
<P>

So we have deadlock and database server is halted and can't serve any client.
The reason of this deadlock is loop in locking graph. Let's explain it less 
formally. We will construct oriented graph G of monitor lock relations.
As far as locked resource are objects, so vertexes of this graph should be 
objects. But this analysis can't be done statically, because set of all object
instances is not known at compile time. So the only kind
of analysis, which Jlint is able to perform, is analysis of inter-class
dependencies. So the vertexes of graph G will be classes. More precisely, 
each class C is represented by two vertexes: vertex C for class itself and 
vertex C' for metaclass. First kind of vertexes are used for dependencies
caused by instance methods invocation, and second - by static methods.
We will add edge (A,B) with mark "foo" to the graph if some synchronized 
method  <CODE>foo()</CODE> of class B, can be invoked directly or indirectly 
from  some synchronized method of class A for object other than 
<CODE>this</CODE>.
For example for the following classes:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    class A {
        public synchronized void f1(B b) { 
            b.g1();
            f1();
            f2();
        }
        public void f2(B b) { 
            b.g2();
        }
        public static synchronized void f3() { 
            B.g3();
        }
    }        
    class B { 
        public static A ap;
        public static B bp;
        public synchronized void g1() { 
            bp.g1();
        }
        public synchronized void g2() { 
            ap.f1();
        } 
        public static synchronized void g3() { 
            g3();
        }
    }
</pre></td></tr></table></P><P>

will add the following edges: 
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>      g1
A  --------&#62; B,  because of invocation of b.g1() from A.f1() 

      g2
A  --------&#62; B,  because of following call sequence: A.f1 -&#62; A.f2 -&#62; B.g2 

      g3
A' --------&#62; B', because of invocation of b.g3() from A.f3() 

      g1
B  --------&#62; B,  loop edge because of recursive call for non-this object in B.g1(). 

      f1
B  --------&#62; A,  because of invocation of ap.f1() from B.g2()
</pre></td></tr></table></P><P>

Deadlock is possible only if there is loop in graph G. This condition is 
necessary, but not enough (presence of loop in graph G doesn't mean that
program is not correct and deadlock can happen during it's execution). 
So using this criterion Jlint can produce messages about deadlock probability 
in case where deadlock is not possible.
</P><P>

As far as task of finding all loops in the graph belongs to the NP class, 
no efficient algorithm for reporting all such loops exists at this moment.
To do it work best and fast, Jlint uses restriction for number of loops, which 
pass through some graph vertex.
</P><P>

There is another source of deadlock - execution of <CODE>wait()</CODE> method.
This method unlocks monitor of current object and waits until some other thread
notify it. Both methods <CODE>wait()</CODE> and <CODE>notify()</CODE>
should be called with monitor locked. When thread is awaken from wait state,
it tries to re-establish monitor lock and only after it can continue 
execution. The problem with <CODE>wait()</CODE> is that only one monitor is 
unlocked. If method executing <CODE>wait()</CODE> was invoked from synchronized
method of some other object O, monitor of this object O will not be released by
<CODE>wait</CODE>. If thread, which should notify sleeping thread, needs to
invoke some synchronized method of object O, we will have deadlock:
one thread is sleeping and thread, which can awoke it, waits until monitor
will be unlocked. Jlint is able to detect situations when <CODE>wait()</CODE>
method is called and more than one monitors are locked.
</P><P>

But deadlock is not the only synchronization problem. Race condition or 
concurrent access to the same data is more serious problem. 
Let's look at the following class:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    class Account { 
        protected int balance; 
    
        public boolean get(int sum) {
            if (sum &#62; balance) { 
                balance -= sum;
                return true;
            }
            return false;
        }
    }
</pre></td></tr></table></P><P>

What will happen if several threads are trying to get money from the same 
account? For example account balance is $100. First thread tries to get 
$100 from the account - check is ok. Then, before first thread can update
account balance, second thread tries to perform the same operation.
Check is ok again! This situation is called <EM>race condition</EM>,
because result depends on "speed" of threads execution.
</P><P>

How can Jlint detect such situations? First of all Jlint builds
closure of all methods, which can be executed concurrently. The obvious 
candidates are synchronized methods and method <CODE>run</CODE> of classes
implemented <CODE>Runnable</CODE> protocol or inherited from 
<CODE>Thread</CODE> class. Then all other methods, which can be invoked from 
these methods, are marked as concurrent. This process repeats until no
more method can be added to concurrent closure. Jlint produces message
about non-synchronized access only if all of the following conditions
are true:
</P><P>

<OL>
<LI>Method accessing field is marked as concurrent.
<LI>Field is not declared as <CODE>volatile</CODE> or <CODE>final</CODE>.
<LI>Field doesn't belong to <CODE>this</CODE> object of the method.
<LI>It is not a field of just created object, which is accessed through local
variable.
<LI>Field can be accessed from methods of different classes.
</OL>
  
It is necessary to explain last two items. When object is created and 
initialized, usually only one thread can access this object through 
its local variables. So synchronization is not needed in this case.
The explanation of item 5 is that not all objects, which are accessed by 
concurrent threads, need to be synchronized (and can't be declared as
synchronized in some cases to avoid deadlocks). 
For example consider implementation of database set:
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    class SetMember { 
        public SetMember next;
        public SetMember prev;
    }
    class SetOwner { 
        protected SetMember first;
        protected Setmember last;

        public synchronized void add_first(SetMember mbr) { 
            if (first == null) { 
                first = last = mbr;
                mbr.next = mbr.prev = null;
            } else { 
                mbr.next = first;
                mbr.prev = null;
                first.prev = mbr;
                first = mbr;
            }
        }
        public synchronized void add_last(SetMember mbr) {...}
        public synchronized void remove(SetMember mbr) {...}
    };
</pre></td></tr></table></P><P>

In this example <CODE>next</CODE> and <CODE>prev</CODE> components
of class <CODE>SetMember</CODE> can be accessed only from synchronized
methods of <CODE>SetOwner</CODE> class, so no access conflict is possible.
Rule 5 was included to avoid reporting of messages in situations like this.
</P><P>

Rules for detecting synchronization conflicts by Jlint are not finally
defined, some of them can be refused or replaced, new candidates can be 
added. The main idea is to detect as much suspicious places as possible, while
not producing confusing messages for correct code.
</P><P>

<HR SIZE="6">
<A NAME="SEC27"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC26"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC28"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.1.1 Loop <VAR>id</VAR>: invocation of synchronized method <VAR>name</VAR> can cause deadlock </H3>
<!--docid::SEC27::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>deadlock</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>sync_loop</STRONG></TD>
</TR></TABLE>
<P>

Loop in class graph G See section <A HREF="manual.html#SEC26">3.1 Synchronization</A> is
detected. One such message is produced for each edge of the loop.
All loops are assigned unique identifier, so it is possible to 
distinguish messages for edges of one loop from another.
</P><P>

<HR SIZE="6">
<A NAME="SEC28"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC27"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC29"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC29"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.1.2 Loop <VAR>LoopId/PathId</VAR>: invocation of method <VAR>name</VAR> forms the loop in class dependency graph </H3>
<!--docid::SEC28::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>deadlock</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>loop</STRONG></TD>
</TR></TABLE>
<P>

Reported invocation is used in call sequence from synchronized method of class
A to synchronized method <CODE>foo()</CODE> of class B, 
so that edge (A,B) is in class graph G 
(See section <A HREF="manual.html#SEC26">3.1 Synchronization</A>). 
If method <CODE>foo()</CODE> is invoked directly, then only previous message
(sync_loop) is reported. But if call sequence includes some other invocations
(except invocation of <CODE>foo()</CODE>), then this message is produced for 
each element of call sequence. If several call paths exist for classes A, B
and method <CODE>foo()</CODE>, then all of them (but not more than specified
by <CODE>MaxShownPaths</CODE> parameter) are printed. <VAR>PathId</VAR> 
identifier is used to group messages for each path.
</P><P>

<HR SIZE="6">
<A NAME="SEC29"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC28"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC30"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.1.3 Lock <VAR>a</VAR> is requested while holding lock <VAR>b</VAR>, with other thread holding <VAR>a</VAR> and requesting lock <VAR>b</VAR> </H3>
<!--docid::SEC29::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>deadlock</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>lock</STRONG></TD>
</TR></TABLE>
<P>

This is one of the extensions for version 2: checking <CODE>synchronized</CODE> blocks. If, for one class, the locking scheme is such that it could lead to a cycle in the locking graph, this message is shown.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>public void foo() {
  synchronized (a) {
    synchronized (b) { }
  }
}

public void bar() {
  synchronized (b) {
    synchronized (a) { }
  }
}
</pre></td></tr></table>In this example, <CODE>a</CODE> and <CODE>b</CODE> are two objects that are used as locks and are shared between threads. If one thread call <CODE>foo</CODE> while another one calls <CODE>bar</CODE> simultaneously, a deadlock occurs. Jlint does not check whether <CODE>a</CODE> and <CODE>b</CODE> are actually used by several threads. However, if this were not the case, there is no point of using synchronizations on these variables.
</P><P>

<HR SIZE="6">
<A NAME="SEC30"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC29"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC31"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC31"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.1.4 Method wait() can be invoked with monitor of other object locked </H3>
<!--docid::SEC30::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>deadlock</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>wait</STRONG></TD>
</TR></TABLE>
<P>

At the moment of <CODE>wait()</CODE> method invocations, more than one monitor
objects are locked by the thread. As far as wait unlocks only one monitor, 
it can be a reason of deadlock. 
Successive messages of type <STRONG>wait_path</STRONG> specify
call sequence, which leads to this invocation.
Monitors can be locked by invocation of a synchronized method or by
explicit synchronized construction. Jlint handle both of the cases.
</P><P>

The extended Jlint now checks <EM>which</EM> locks are actually owned before issuing an error message. This error message now spans two lines, with the second line saying which locks are owned at that point. (Jlint will still count this as only one message when printing the total message count.) This should greatly facilitate debugging.
</P><P>

<HR SIZE="6">
<A NAME="SEC31"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC30"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC32"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC32"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.1.5 Call sequence to method <VAR>name</VAR> can cause deadlock in wait() </H3>
<!--docid::SEC31::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>deadlock</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>wait_path</STRONG></TD>
</TR></TABLE>
<P>

By the sequence of such messages Jlint informs about possible invocation chain,
which locks at least two object monitors and is terminated by method
calling <CODE>wait()</CODE>. As far as <CODE>wait()</CODE> unlocks only one 
monitor and suspend thread, this can cause deadlock.
</P><P>

<HR SIZE="6">
<A NAME="SEC32"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC31"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC33"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC33"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.1.6 Synchronized method <VAR>name</VAR> is overridden by non-synchronized method of derived class <VAR>name</VAR> </H3>
<!--docid::SEC32::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>race_condition</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>nosync</STRONG></TD>
</TR></TABLE>
<P>

Method is declared as synchronized in base class, but is overridden in derived
class by non-synchronized method. It is not a bug, but suspicious place, 
because if base method is declared as synchronized, then it is expected that
this method can be called from concurrent threads and access some critical 
data. Usually the same is true for derived method, so disappearance of 
synchronized modifier looks suspiciously. 
</P><P>

<HR SIZE="6">
<A NAME="SEC33"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC32"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC34"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC34"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.1.7 Method <VAR>name</VAR> can be called from different threads and is not synchronized </H3>
<!--docid::SEC33::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>race_condition</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>concurrent_call</STRONG></TD>
</TR></TABLE>
<P>

Non-synchronized method is invoked from method marked as concurrent for
object other than <CODE>this</CODE> (for instance methods) or for class,
which is not base class of caller method class (for static methods). 
This message is reported only if invocation is not enclosed in synchronized 
construction and this method also can be invoked from methods of other classes.
</P><P>

<HR SIZE="6">
<A NAME="SEC34"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC33"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC35"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC35"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.1.8 Field <VAR>name</VAR> of class </H3>
<!--docid::SEC34::-->
<VAR>name</VAR> can be accessed from different threads and is not volatile
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>race_condition</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>concurrent_access</STRONG></TD>
</TR></TABLE>
<P>

Field is accessed from method marked as concurrent. 
This message is produced only if:
</P><P>

<OL>
<LI>Field belongs to the object other than
<CODE>this</CODE> (for instance methods) or to classes which are not base for 
class of static method.
<LI>Field is not component of object previously created by <CODE>new</CODE>
and assigned to local variable.
<LI>Field is not marked as volatile or final.
<LI>Field can be accessed from methods of different classes.
</OL>
<P>

<HR SIZE="6">
<A NAME="SEC35"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC34"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC36"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.1.9 Method <VAR>name</VAR> implementing 'Runnable' interface is not synchronized </H3>
<!--docid::SEC35::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>race_condition</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>run_nosync</STRONG></TD>
</TR></TABLE>
<P>

Method <CODE>run()</CODE> of class implementing <CODE>Runnable</CODE> interface
is not declared as synchronized. As far as different threads can be started
for the same object implementing <CODE>Runnable</CODE> interface, method
<CODE>run</CODE> can be executed concurrently and is first candidate
for synchronization.
</P><P>

<HR SIZE="6">
<A NAME="SEC36"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC35"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC37"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC28"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.1.10 Value of lock <VAR>name</VAR> is changed outside synchronization or constructor </H3>
<!--docid::SEC36::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>deadlock</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>loop_assign</STRONG></TD>
</TR></TABLE>
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>class Foo {
  Object a = new Object();

  public void bar() {
    a = new Object();
    synchronized (a) { }
  }
}
</pre></td></tr></table></P><P>

The initialization of <VAR>a</VAR> (in the declaration, which will be moved into the constructor) is OK; however, changing the value outside any synchronization will make <VAR>a</VAR> useless as a locking variable. Therefore, Jlint will issue a warning for the assignment <CODE>a = new Object();</CODE> in <CODE>bar</CODE>.
</P><P>

<HR SIZE="6">
<A NAME="SEC37"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC36"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC38"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC28"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.1.11 Value of lock <VAR>name</VAR> is changed while (potentially) owning it </H3>
<!--docid::SEC37::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>deadlock</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>loop_assign2</STRONG></TD>
</TR></TABLE>
<P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>class Quux {
  Object a = new Object();

  public void foo() {
    synchronized (a) {
      bar();
    }
  }
  
  public void bar() {
    a = new Object();
    /* do something */
  }
}
</pre></td></tr></table></P><P>

In this example, the current thread still holds a lock on <VAR>a</VAR> when it re-initialized that variable (in method <CODE>bar</CODE>). This means that if another thread tried to obtain a lock on the new <VAR>a</VAR>, it can now proceed to do so, because the new value of <VAR>a</VAR> points to a different instance, which makes a synchronization on <VAR>a</VAR> ineffective. Probably this was not expected by the programmer, and this could lead to a potential race condition. The solution to this problem is to include another guard (in this case, <CODE>synchronized(this)</CODE>).
</P><P>

<HR SIZE="6">
<A NAME="SEC38"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC37"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC39"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC28"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.1.12 Method <CODE><VAR>name</VAR>.wait()</CODE> is called without synchronizing on <VAR>name</VAR> </H3>
<!--docid::SEC38::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>wait_nosync</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>wait_nosync</STRONG></TD>
</TR></TABLE>
<P>

Method <CODE>wait()</CODE> or <CODE>notify()</CODE> is invoked from method, 
which is not declared as synchronized. It is not surely a bug, because
monitor can be locked from another method, which directly or indirectly
invokes current method.
</P><P>

The improved Jlint (version 2) can also check <CODE>wait</CODE> calls to any object, and it will not report an error as long as the lock on <VAR>name</VAR> was obtained within the method that is currently being checked. This greatly reduces the amount of spurious warnings in that category.
</P><P>

<A NAME="Inheritance"></A>
</P><P>

<HR SIZE="6">
<A NAME="SEC39"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC38"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC40"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC26"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC44"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 3.2 Inheritance </H2>
<!--docid::SEC39::-->
<P>

This group contains messages, 
which are caused by problems with class inheritance: such
as mismatch of methods profiles, components shadowing... As far as Jlint
deals with Java class file and there is no information about line number
in source file of class, field or method definition, Jlint can't show
proper place in source file where class, field or method, which cause the 
problem, is located. In case of methods, Jlint points to the line corresponds 
to the first instruction of the method. And for classes and fields, Jlint 
always refers in message to the first line in source file. Jlint assign
successive number (starting from 1) for all such message reported sequentially,
because Emacs skips all messages, reported for the same line, when you go to 
next message.
</P><P>

<HR SIZE="6">
<A NAME="SEC40"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC39"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC41"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.2.1 Method <VAR>name</VAR> is not overridden by method with the same name of derived class <VAR>name</VAR> </H3>
<!--docid::SEC40::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>not_overridden</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>not_overridden</STRONG></TD>
</TR></TABLE>
<P>

Derived class contains the method with the same name as in base class, but
profiles of these methods do not match. More precisely: message is 
reported when for some method of class A, exists
method with the same name in derived class B, but there is no method with
the same name in class B, which is compatible with definition of the method 
in class A (with the same number and types of parameters). 
Programmer writing this code may 
erroneously expect that method in derived class overrides method in base 
class and that virtual call of method of base class for object of derived 
class will cause execution method of the derived class.
</P><P>

<HR SIZE="6">
<A NAME="SEC41"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC40"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC42"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC42"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.2.2 Component <VAR>name</VAR> in class <VAR>name</VAR> shadows one in base class <VAR>name</VAR> </H3>
<!--docid::SEC41::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>field_redefined</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>field_redefined</STRONG></TD>
</TR></TABLE>
<P>

Field in derived class has the same name as field of some of base classes.
It can cause some problems because this two fields points to different 
locations and methods of base class will access one field, while methods
of derived class (and classes derived from it) will access another field. 
Sometimes it is what programmer expected, but in any case it will not
improve readability of program. 
</P><P>

<HR SIZE="6">
<A NAME="SEC42"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC41"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC43"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC43"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.2.3 Local variable <VAR>name</VAR> shadows component of class <VAR>name</VAR> </H3>
<!--docid::SEC42::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>shadow_local</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>shadow_local</STRONG></TD>
</TR></TABLE>
<P>

Local variable of method shadows class component with the same name. 
As far as it is common practice in constructors to use formal parameters
with the same name as class components, Jlint detects situations, when
class field is explicitly accessed by using <CODE>this</CODE>
reference and doesn't report this message in this case:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    class A { 
        public int a;
        public void f(int a) { 
            this.a = a; // no message
        }
        public int g(int a) { 
            return a; // message "shadow_local" will be reported
        }
    }
</pre></td></tr></table>            
</P><P>

<HR SIZE="6">
<A NAME="SEC43"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC42"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC44"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.2.4 Method <CODE>finalize()</CODE> doesn't call <CODE>super.finalize()</CODE> </H3>
<!--docid::SEC43::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>super_finalize</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>super_finalize</STRONG></TD>
</TR></TABLE>
<P>

As it is mentioned in book "The Java Programming Language" by Ken Arnold
and James Gosling, calling of <CODE>super.finalize()</CODE> from 
<CODE>finalize()</CODE> is good practice of programming, 
even if base class doesn't define <CODE>finalize()</CODE> method. 
This makes class implementations less dependent from each other.
</P><P>

<A NAME="Data flow"></A>
</P><P>

<HR SIZE="6">
<A NAME="SEC44"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC43"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC45"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC39"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 3.3 Data flow </H2>
<!--docid::SEC44::-->
<P>

Jlint performs data flow analysis of Java byte code, calculating
possible ranges of values of expressions and local variables. 
For integer types, Jlint calculates minimal and maximal value of expression 
and mask of possibly set bits. For object variables attribute 
<CODE>null/not_null</CODE> is calculated, selecting variables which value can 
be <CODE>null</CODE>.
When value of expression is assigned to variable, 
these characteristics are copied to correspondent variable descriptor. 
Jlint handles control transfer instruction in special way: saving,
modifying, merging or restoring context depending on type of instruction.
Context in this consists of local variables states (minimal, maximal 
values and mask) and state of top of the stack (for handling ?: instruction).
Initially all local integer variable are considered to have minimum and maximum
properties equal to the range of correspondent type, and mask indicating
that all bits in this range can be set. Object variables attribute initially
is set to <CODE>not_null</CODE>. The same characteristics are always used
for class components, because Jlint is not able to perform full data flow
analysis (except checking for passing null value to formal parameter of 
methods). 
Table below summarizes actions performed by Jlint for handling 
control transfer instruction:
</P><P>

<TABLE>
<TR><TD>Instruction type</TD>
</TD><TD> Correspondent Java construction
</TD><TD> Action
</TR>
<TR><TD>Forward conditional jump</TD>
</TD><TD> IF statement
</TD><TD> Save current context. Modify current context in assumption that
condition is false (no jump). Modify saved context
in assumption that condition is true (jump takes place)

</TR>
<TR><TD>Forward unconditional jump</TD>
</TD><TD> Start of loop, jump around ELSE branch of IF
</TD><TD> Save current context

</TR>
<TR><TD>Backward conditional jump</TD>
</TD><TD> Loop statement condition
</TD><TD> Modify context in assumption that condition is false (no jump)

</TR>
<TR><TD>Backward unconditional jump</TD>
</TD><TD> Infinite loop
</TD><TD> Do nothing

</TR>
<TR><TD>Label of forward jump</TD>
</TD><TD> End of IF body or SWITCH case
</TD><TD> If previous instruction is no-pass instruction (return, 
unconditional jump, throw exception) then restore saved context, 
otherwise merge current context with saved context (set minimum
property of integer variable to minimum of this property value 
in current and saved contexts, maximum - to maximum of
values in two contexts, and mask as join of masks in two context;
for object variable - mark it as "may contain null" if it is marked so
in one of contexts). If label corresponds to switch statement case,
and switch expression is single local variable, then update
properties of this variable by setting its minimum and maximum values 
and mask to value of case selector.

</TR>
<TR><TD>Label of backward jump</TD>
</TD><TD> Start of loop body
</TD><TD> Reset properties of all variables modified between this label
and backward jump instructions. Reset for integer variables means
setting minimum property to minimum value of correspondent type, ...
Reset for object variable clears mark "may contain null".

</TR></TABLE>
<P>

<HR SIZE="6">
<A NAME="SEC45"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC44"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC46"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.3.1 Method <VAR>name</VAR> can be invoked with NULL as <VAR>number</VAR> parameter and this parameter is used without check for null </H3>
<!--docid::SEC45::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>null_reference</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>null_param</STRONG></TD>
</TR></TABLE>
<P>

Formal parameter is used in the method without check for null
(component of object is accessed or method of this object is invoked), while
this method can be invoked with null as the value of this parameter (detected
by global data flow analysis). Example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    class Node { 
        protected Node next;
        protected Node prev;
        public void link(Node after) { 
            next = after.next; // Value of 'after' parameter can be null
            prev = after;
            after.next = next.prev = this;
        }
    }
    class Container { 
        public void insert(String key) { 
            Node after = find(key);
            if (after == null) { 
                add(key);
            }   
            Node n = new Node(key);
            n.link(after); // after can be null
        }
    }
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC46"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC45"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC47"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC47"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.3.2 Value of referenced variable <VAR>name</VAR> may be NULL </H3>
<!--docid::SEC46::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>null_reference</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>null_var</STRONG></TD>
</TR></TABLE>
<P>

Variable is used in the method without check for null. 
Jlint detects that referenced variable was previously assigned 
<CODE>null</CODE> value or was found to be <CODE>null</CODE> in one of 
control paths in the method.
</P><P>

Jlint can produce this message in some situations, when value of variable
can not actually be null:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    public int[] create1nVector(int n) { 
        int[] v = null;
        if (n &#62; 0) { 
            v = new int[n];
        }
        for (int i = 0; i &#38;lt; n; i++) { 
            v[i] = i+1; // message will be reported
        }
        return v;
    }
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC47"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC46"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC48"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC48"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.3.3 NULL reference can be used </H3>
<!--docid::SEC47::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>null_reference</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>null_ptr</STRONG></TD>
</TR></TABLE>
<P>

Constant <CODE>null</CODE> is used as left operand of '.' operation:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    public void printMessage(String msg) { 
        (msg != null ? new Message(msg) : null).Print();
    }
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC48"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC47"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC49"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC49"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.3.4 Zero operand for operation </H3>
<!--docid::SEC48::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>zero_operand</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>zero_operand</STRONG></TD>
</TR></TABLE>
<P>

One of operands of binary operation is zero. 
This message can be produced for sequence of code like this:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    int x = 0;
    x += y;
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC49"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC48"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC50"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC50"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.3.5 Result of operation is always 0 </H3>
<!--docid::SEC49::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>zero_result</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>zero_result</STRONG></TD>
</TR></TABLE>
<P>

Jlint detects that for given operands, operation always produces zero
result. This can be caused by overflow for arithmetic operations or
by shifting all significant bits in shift operations or clearing all
bits by bit AND operation.
</P><P>

<HR SIZE="6">
<A NAME="SEC50"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC49"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC51"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC51"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.3.6 Shift with count <VAR>relation</VAR> than <VAR>integer</VAR> </H3>
<!--docid::SEC50::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>domain</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>shift_count</STRONG></TD>
</TR></TABLE>
<P>

This message is reported when minimal value of shift count operand exceeds
31 for int type and 63 for long type or maximal value of shift count operand 
is less than 0:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    if (x &#62; 32) { 
        y &#62;&#62;= x; // Shift right with count greater than 32
    }
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC51"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC50"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC52"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC52"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.3.7 Shift count range [<VAR>min,max</VAR>] is out of domain </H3>
<!--docid::SEC51::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>domain</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>shift_count</STRONG></TD>
</TR></TABLE>
<P>

Range of shift count operand is not within [0,31] for int type or
[0,63] for long type. Jlint doesn't produce this message when
distance between maximum and minimum values of shift count is greater than 255.
So this message will not be reported if shift count is just variable
of integer type:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    public int foo(int x, int y) { 
        x &#62;&#62;= y; // no message
        x &#62;&#62;= 32 - (y &#38; 31); // range of count is [1,32]
    }
</pre></td></tr></table>    
</P><P>

<HR SIZE="6">
<A NAME="SEC52"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC51"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC53"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC53"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.3.8 Range of expression value has no intersection with <VAR>target</VAR> type domain </H3>
<!--docid::SEC52::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>domain</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>conversion</STRONG></TD>
</TR></TABLE>
<P>

Converted value is out of range of target type. This message can be reported 
not only for explicit conversions, but also for implicit conversions 
generated by compiler:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    int x = 100000;
    short s = x; // will cause this message
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC53"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC52"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC54"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC2"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.3.9 Data can be lost as a result of truncation to <VAR>type</VAR> </H3>
<!--docid::SEC53::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>truncation</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>truncation</STRONG></TD>
</TR></TABLE>
<P>

This message is reported when significant bits can be lost as a result
of conversion from large integer type to smaller. Such conversions are 
always explicitly specified by programmer, so Jlint tries to reduce number of 
reported messages caused by data truncation. Example below shows when Jlint
produces this message and when not:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    public void foo(int x, long y) { 
        short s = (short)x; // no message
        char  c = (char)x;  // no message
        byte  b = (byte)y;  // no message
        b = (byte)(x &#38; 0xff); // no message
        b = (byte)c; // no message
        c = (x &#38; 0xffff); // no message
        x = (int)(y &#62;&#62;&#62; 32); // no message


        b = (byte)(x &#62;&#62; 24);     // truncation
        s = (int)(x &#38; 0xffff00); // truncation
        x = (int)(y &#62;&#62;&#62; 1);      // truncation 
        s = (short)c;            // truncation 
    }
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC54"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC53"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC55"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC46"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.3.10 May be type cast is not correctly applied </H3>
<!--docid::SEC54::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>overflow</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>overflow</STRONG></TD>
</TR></TABLE>
<P>

Result of operation, which has good chance to cause overflow 
(multiplication, left shift), is converted to long. As far as operation is performed with <CODE>int</CODE> operands, overflow can happen before conversion.
Overflow can be avoided by conversion of one of operation operands to long, 
so operation will be performed with <CODE>long</CODE> operands.
This message is produced not only for explicit type conversion done by 
programmer, but also for implicit type conversions performed by compiler:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    public long multiply(int a, int b) { 
        return a*b; // operands are multiplied as integers 
                    // and then result will be converted to long
    }
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC55"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC54"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC56"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC46"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.3.11 Comparison always produces the same result </H3>
<!--docid::SEC55::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>redundant</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>same_result</STRONG></TD>
</TR></TABLE>
<P>

Using information about possible ranges of operands values, Jlint can
make a conclusion, that logical expression is always evaluated to the
same value (<CODE>true</CODE> or <CODE>false</CODE>):
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>     public void foo(int x) { 
         if (x &#62; 0) { 
             ...
             if (x == 0) // always false
             {
             }
         }
     }
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC56"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC55"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC57"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC46"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.3.12 Compared operands can be equal only when both of them are 0 </H3>
<!--docid::SEC56::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>redundant</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>disjoint_mask</STRONG></TD>
</TR></TABLE>
<P>

By comparing operands masks, Jlint makes a conclusion that 
operands of <CODE>==</CODE> or <CODE>!=</CODE> operations can be equal 
only when both of them are zero:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    public boolean foo(int x, int y) { 
        return ((x &#38; 1) == y*2); // will be true only for x=y=0 
    }
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC57"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC56"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC58"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC46"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.3.13 Reminder always equal to the first operand </H3>
<!--docid::SEC57::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>redundant</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>redundant</STRONG></TD>
</TR></TABLE>
<P>

This message is produced for <CODE>%</CODE> operation when right operand
is either greater either less than zero, and absolute value of left operand
is less than absolute value of right operand. In this case 
<CODE>x % y == x</CODE> or <CODE>x % y == -x</CODE>.
</P><P>

<HR SIZE="6">
<A NAME="SEC58"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC57"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC59"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC46"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.3.14 Comparison of short with char </H3>
<!--docid::SEC58::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>short_char_cmp</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>short_char_cmp</STRONG></TD>
</TR></TABLE>
<P>

Comparison of <CODE>short</CODE> operand with <CODE>char</CODE> operand.
As far as <CODE>char</CODE> type is unsigned, and is converted to 
<CODE>int</CODE> by filling high half of the word with 0, and 
<CODE>short</CODE> type is signed and is converted to <CODE>int</CODE> 
using sign extension, then symbols in range <CODE>0x8000...0xFFFF</CODE>
will not be considered equal in such comparison:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>     boolean cmp() { 
        short s = (short)0xabcd;
        char c = (char)s;
        return (c == s); // false
     }
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC59"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC58"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC60"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC46"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.3.15 Compare strings as object references </H3>
<!--docid::SEC59::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>string_cmp</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>string_cmp</STRONG></TD>
</TR></TABLE>
<P>

String operands are compared by <CODE>==</CODE> or <CODE>!=</CODE> operator.
As far as <CODE>==</CODE> returns <CODE>true</CODE> only if operands
point to the same object, so it can return false for two strings with same 
contents. The following function will return <CODE>false</CODE>
in JDK1.1.5:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    public boolean bug() {
        return Integer.toString(1) == Integer.toString(1);
    }
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC60"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC59"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC61"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC46"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.3.16 Inequality comparison can be replaced with equality comparison </H3>
<!--docid::SEC60::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>weak_cmp</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>weak_cmp</STRONG></TD>
</TR></TABLE>
<P>

This message is produced in situations when ranges of compared operands
intersect only in one point. So inequality comparison can be replaced
with equality comparison. Such message can be caused by error in program,
when programmer has wrong assumption about ranges of compared operands.
But even if this inequality comparison is correct, replacing it with
equality comparison can make code more clear:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    public void foo(char c, int i) { 
        if (c &#38;lt;= 0) { // is it a bug ?
            if ((i &#38; 1) &#62; 0) { // can be replaced with (i &#38; 1) != 0
                ...
            } 
        }  
    }
</pre></td></tr></table></P><P>

<HR SIZE="6">
<A NAME="SEC61"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC60"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC46"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.3.17 Switch case constant <VAR>integer</VAR> can't be produced by switch expression </H3>
<!--docid::SEC61::-->
<P>

<TABLE>
<TR><TD>Message category: </TD><TD> <STRONG>incomp_case</STRONG></TD>
</TR>
<TR><TD>Message code: </TD><TD> <STRONG>incomp_case</STRONG></TD>
</TR></TABLE>
<P>

Constant in switch case is out of range of switch expression or
has incompatible bit mask with switch expression:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    public void select(char ch, int i) { 
        switch (ch) { 
          case 1:          
          case 2:          
          case 3:          
            ...
          case 256: // constant is out of range of switch expression
        }
        switch (i &#38; ~1) { 
          case 0:  
          case 0xabcde:  
            ...
          case 1: // switch expression is always even
        }
    }
</pre></td></tr></table>   
</P><P>

<A NAME="Command line options"></A>
</P><P>

<HR SIZE="6">
<A NAME="SEC62"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC61"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC63"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC66"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 4. Command line options </H1>
<!--docid::SEC62::-->
<P>

Both programs (AntiC and Jlint) accept list of files separated by spaces
in command line. Wildcards are permitted. But unlike Unix, where
wildcards are substituted by shell, in Windows wildcards are handled
by program itself and wildcards only in file names (not in path directories)
are allowed. 
</P><P>

<A NAME="AntiC command line options"></A>
</P><P>

<HR SIZE="6">
<A NAME="SEC63"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC64"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC66"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 4.1 AntiC command line options </H2>
<!--docid::SEC63::-->
<P>

AntiC supports only one command option: "-java". By default it consider
input files as C/C++ source. There are very few differences
(from AntiC point of view) between Java and C++. The differences are mostly 
with set of tokens and Unicode character constants.
</P><P>

<A NAME="Jlint command line options"></A>
</P><P>

<HR SIZE="6">
<A NAME="SEC64"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC63"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC65"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC66"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 4.2 Jlint command line options </H2>
<!--docid::SEC64::-->
<P>

Jlint option can be placed in any position in command line and takes
effect for verification of all successive files in command line. 
Option always overrides previous occurrence of the same option. 
Some options specify parameters of global analysis, which is performed after 
loading of all files, so only the last occurrence of such options takes 
effect.
</P><P>

Options are always compared ignoring letters case and <VAR>'_'</VAR>
symbols. So the following two strings specify the same option:
<VAR>-ShadowLocal</VAR> and <VAR>-shadow_local</VAR>.
</P><P>

All Jlint options are prefixed by <VAR>'-'</VAR> or <VAR>'+'</VAR>.
For options, which can be enabled or disabled, <VAR>'+'</VAR> means that option 
is enabled and <VAR>'-'</VAR> means that option is disabled. 
For options like <VAR>source</VAR> or <VAR>help</VAR> there is no
difference between <VAR>'-'</VAR> and <VAR>'+'</VAR>.
</P><P>

<DL COMPACT>
<DT><SAMP>`-source <EM><STRONG>path</STRONG></EM>'</SAMP>
<DD>Specifies path to source files. It is necessary to specify this option when
sources and class files are located in different directories. For example:
<VAR>jlint -source /usr/local/jdk1.1.1/src /usr/local/jdk1.1.1/lib/classes.zip</VAR>. 
<P>

<DT><SAMP>`-history <EM><STRONG>file</STRONG></EM>'</SAMP>
<DD>Specifies history file. Jlint will not repeatedly report messages,
which are present in history file. History file should be available for
reading/writing and is appended by new messages after each Jlint execution.
This messages will not be more reported in successive executions of Jlint
(certainly if <VAR>-history</VAR> options is present and specifies the same 
history file).
<P>

<DT><SAMP>`-max_shown_paths <EM><STRONG>number</STRONG></EM>'</SAMP>
<DD>Specifies number of different paths between two vertexes in class graph used
for detecting possible deadlocks 
(See section <A HREF="manual.html#SEC26">3.1 Synchronization</A>). 
Default value of this parameter is 4.
Increasing of this value can increase time of verification for complex 
programs. 
 
<DT><SAMP>`-help'</SAMP>
<DD>Output list of all options, including message categories. If option
<VAR>+verbose</VAR> was previously specified, then list of all messages
is also printed.  
<P>

<DT><SAMP>`(+-)verbose'</SAMP>
<DD>Switch on/off verbose mode. In verbose mode Jlint outputs more information
about process of verification: names of verified files, warnings about
absence of debugging information...
<P>

<DT><SAMP>`(+-)<EM><STRONG>message_category</STRONG></EM>'</SAMP>
<DD>Enable or disable reporting of messages of specified category. 
It is possible to disable top level category and then enable some 
sub-categories within this category. And visa-versa it is possible to 
disable some specific categories within top-level category.
It is also possible to disable concrete message codes within category.
Table below describes full hierarchy of messages. By default all categories are
enabled.
<P>

<DT><SAMP>`(+-)all'</SAMP>
<DD>Enable/disable reporting of all messages. If <VAR>-all</VAR> is specified,
it is possible to enable reporting of some specific categories of messages.
For example to output only synchronization messages it is enough to specify
"<VAR>-all +synchronization</VAR>". 
<P>

<DT><SAMP>`(+-)<EM><STRONG>message_code</STRONG></EM>'</SAMP>
<DD>Enable or disable reporting of concrete message. 
Message will be reported if its category is enabled and 
message code is enabled. If there is only one message code in the 
category, then names of the category and message code are the same.
By default all messages are enabled.
</DL>
<P>

<A NAME="Jlint messages hierarchy"></A>
</P><P>

<HR SIZE="6">
<A NAME="SEC65"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC64"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC66"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC25"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC66"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 4.3 Jlint messages hierarchy </H2>
<!--docid::SEC65::-->
&#60;table border="1" align="center"&#62;
&#60;TR&#62;
&#60;TH&#62;Top level category&#60;/TH&#62;
&#60;TH&#62;subcategory&#60;/TH&#62;
&#60;TH&#62;Message code&#60;/TH&#62;
&#60;/TR&#62;
&#60;TR&#62;
&#60;TH ROWSPAN=12&#62;Synchronization&#60;/TH&#62;
&#60;TH ROWSPAN=5&#62;deadlock&#60;/TH&#62;
&#60;TD&#62;syncLoop&#60;/TD&#62;
&#60;/TR&#62;
&#60;TR&#62;&#60;TD&#62;loop&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;&#60;TD&#62;lock&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;&#60;TD&#62;wait&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;&#60;TD&#62;waitPath&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;
&#60;TH ROWSPAN=6&#62;raceCondition&#60;/TH&#62;
&#60;TD&#62;noSync&#60;/TD&#62;
&#60;/TR&#62;
&#60;TR&#62;&#60;TD&#62;concurrentCall&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;&#60;TD&#62;concurrentAccess&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;&#60;TD&#62;runNoSync&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;&#60;TD&#62;lockAssign&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;&#60;TD&#62;lockAssign2&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;
&#60;TH&#62;waitNoSync&#60;/TH&#62;&#60;TD&#62;waitNoSync&#60;/TD&#62;
&#60;/TR&#62;
&#60;TR&#62;
&#60;TH ROWSPAN=4&#62;Inheritance&#60;/TH&#62;
&#60;TH&#62;notOverridden&#60;/TH&#62;&#60;TD&#62;notOverridden&#60;/TD&#62;
&#60;/TR&#62;
&#60;TR&#62;&#60;TH&#62;fieldRedefined&#60;/TH&#62;&#60;TD&#62;fieldRedefined&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;&#60;TH&#62;shadowLocal&#60;/TH&#62;&#60;TD&#62;shadowLocal&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;&#60;TH&#62;superFinalize&#60;/TH&#62;&#60;TD&#62;superFinalize&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;
&#60;TH ROWSPAN=17&#62;DataFlow&#60;/TH&#62;
&#60;TH ROWSPAN=3&#62;nullReference&#60;/TH&#62;&#60;TD&#62;nullParam&#60;/TD&#62;
&#60;/TR&#62;
&#60;TR&#62;&#60;TD&#62;nullVar&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;&#60;TD&#62;nullPtr&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;&#60;TH&#62;zeroOperand&#60;/TH&#62;&#60;TD&#62;zeroOperand&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;&#60;TH&#62;zeroResult&#60;/TH&#62;&#60;TD&#62;zeroResult&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;&#60;TH ROWSPAN=3&#62;domain&#60;/TH&#62;&#60;TD&#62;shiftCount&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;&#60;TD&#62;shiftRange&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;&#60;TD&#62;conversion&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;&#60;TH&#62;truncation&#60;/TH&#62;&#60;TD&#62;truncation&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;&#60;TH&#62;overflow&#60;/TH&#62;&#60;TD&#62;overflow&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;&#60;TH ROWSPAN=3&#62;redundant&#60;/TH&#62;&#60;TD&#62;sameResult&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;&#60;TD&#62;disjointMask&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;&#60;TD&#62;noEffect&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;&#60;TH&#62;shortCharCmp&#60;/TH&#62;&#60;TD&#62;shortCharCmp&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;&#60;TH&#62;stringCmp&#60;/TH&#62;&#60;TD&#62;stringCmp&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;&#60;TH&#62;weakCmp&#60;/TH&#62;&#60;TD&#62;weakCmp&#60;/TD&#62;&#60;/TR&#62;
&#60;TR&#62;&#60;TH&#62;incompCase&#60;/TH&#62;&#60;TD&#62;incompCase&#60;/TD&#62;&#60;/TR&#62;
&#60;/TABLE&#62;&#60;P&#62;
<P>

<A NAME="How to build"></A>
</P><P>

<HR SIZE="6">
<A NAME="SEC66"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC65"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC67"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC62"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 5. How to build and use Jlint and AntiC </H1>
<!--docid::SEC66::-->
<P>

Jlint is written on C++, using almost no operation system dependent code,
so I hope it will not a problem to compile it on any system with C++ compiler.
Current release contains makefile for Unix with gcc and for Windows with
Microsoft Visual C++. In both cases it is enough to execute "make" to build
"antic" and "jlint" programs. Distributive for Windows already includes 
executable files.
</P><P>

To use Jlint you need to compile first you Java sources to byte code.
As far as format of Java class is standard, you can use any available Java
compiler. It is preferable to make compiler to include debug information
in compiled classes (line table and local variables mapping). In this case
Jlint messages will be more detailed. If your are using Sun <STRONG>javac</STRONG>
compiler, required option is <VAR>-g</VAR>. Most of compilers by default
includes line table, but do not generate local variable table.
For example free Java compiler <STRONG>guavac</STRONG> can't generate it at all.
Some compilers (like Sun's  <STRONG>javac</STRONG>) can't generate line table if 
optimization is switch on. If you specify <VAR>-verbose</VAR> option to Jlint,
it will report when it can't find line or local variable table in the class 
file.
</P><P>

Now Jlint and AntiC produce message in Emacs format: 
"<VAR>file:line: message text</VAR>".
So it is possible to walk through these messages in Emacs if you start 
Jlint or AntiC as compiler. You can change prefix <VAR>MSG_LOCATION_PREFIX</VAR> 
(defined in 
&#60;a href="types.hh"&#62;types.hh&#60;/a&#62;
<TT>`types.hh'</TT>) from <VAR>"%0s:%1d: "</VAR> 
to one recognized by your favourite editor or IDE. All Jlint messages are
gathered in file
&#60;a href="jlint.msg"&#62;jlint.msg&#60;/a&#62;
<TT>`jlint.msg'</TT>, so you can easily 
change them (but recompilation is needed).
</P><P>

AntiC also includes in the message position in the line. 
All AntiC messages are produced
by function <CODE>message_at(int line, int coln, char* msg)</CODE>, 
defined in file
&#60;a href="antic.c"&#62;antic.c&#60;/a&#62;
<TT>`antic.c'</TT>.
You can change format of reported messages
by modifying this function.
</P><P>

<A NAME="Release notes"></A>
</P><P>

<HR SIZE="6">
<A NAME="SEC67"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC66"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[ &lt;&lt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 6. Release notes </H1>
<!--docid::SEC67::-->
<P>

Jlint is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.
</P><P>

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.
</P><P>

You should have received a copy of the GNU General Public
License along with this library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
MA 02111-1307, USA.
</P><P>

 
</P><P>

&#60;div align="center"&#62;
&#60;h3&#62;Look for a new version&#60;/h3&#62;
&#60;a href="http://artho.com/jlint/"&#62;New Jlint page&#60;/a&#62;&#60;br&#62;
<A HREF="http://www.ispras.ru/~knizhnik/">Konstantin Knizhnik's homepage&#60;/a&#62; (alternative download location); original Jlint page
</P><P>

&#60;h3&#62;E-mail about bugs or problems&#60;/h3&#62;
&#60;a href="mailto:cyrille@artho.com"&#62;Cyrille Artho&#60;/a&#62; - about new synchronization features (synchronized blocks)&#60;br&#62;
<A HREF="mailto:knizhnik@cecmow.enet.dec.com">Konstantin Knizhnik&#60;/a&#62; - other questions
&#60;/div&#62;
</P><P>

<HR SIZE="6">
<A NAME="SEC_Contents"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1>Table of Contents</H1>
<UL>
<A NAME="TOC1" HREF="manual.html#SEC1">1. Introduction</A>
<BR>
<A NAME="TOC2" HREF="manual.html#SEC2">2. Bugs detected by AntiC</A>
<BR>
<UL>
<A NAME="TOC3" HREF="manual.html#SEC3">2.1 Bugs in tokens</A>
<BR>
<UL>
<A NAME="TOC4" HREF="manual.html#SEC4">2.1.1 Octal digit expected</A>
<BR>
<A NAME="TOC5" HREF="manual.html#SEC5">2.1.2 May be more than three octal digits are specified</A>
<BR>
<A NAME="TOC6" HREF="manual.html#SEC6">2.1.3 May be more than four hex digits are</A>
<BR>
<A NAME="TOC7" HREF="manual.html#SEC7">2.1.4 May be incorrect escape sequence</A>
<BR>
<A NAME="TOC8" HREF="manual.html#SEC8">2.1.5 Trigraph sequence inside string</A>
<BR>
<A NAME="TOC9" HREF="manual.html#SEC9">2.1.6 Multi-byte character constants are not portable</A>
<BR>
<A NAME="TOC10" HREF="manual.html#SEC10">2.1.7 May be 'l' is used instead of '1' at the end of integer constant</A>
<BR>
</UL>
<A NAME="TOC11" HREF="manual.html#SEC11">2.2 Operator priorities</A>
<BR>
<UL>
<A NAME="TOC12" HREF="manual.html#SEC12">2.2.1 May be wrong assumption about operators precedence</A>
<BR>
<A NAME="TOC13" HREF="manual.html#SEC13">2.2.2 May be wrong assumption about logical operators precedence</A>
<BR>
<A NAME="TOC14" HREF="manual.html#SEC14">2.2.3 May be wrong assumption about shift operator priority</A>
<BR>
<A NAME="TOC15" HREF="manual.html#SEC15">2.2.4 May be '=' used instead of '=='</A>
<BR>
<A NAME="TOC16" HREF="manual.html#SEC16">2.2.5 May be skipped parentheses around assign operator</A>
<BR>
<A NAME="TOC17" HREF="manual.html#SEC17">2.2.6 May be wrong assumption about bit operation priority</A>
<BR>
</UL>
<A NAME="TOC18" HREF="manual.html#SEC18">2.3 Statement body</A>
<BR>
<UL>
<A NAME="TOC19" HREF="manual.html#SEC19">2.3.1 May be wrong assumption about loop body</A>
<BR>
<A NAME="TOC20" HREF="manual.html#SEC20">2.3.2 May be wrong assumption about IF body</A>
<BR>
<A NAME="TOC21" HREF="manual.html#SEC21">2.3.3 May be wrong assumption about ELSE branch association</A>
<BR>
<A NAME="TOC22" HREF="manual.html#SEC22">2.3.4 Suspicious SWITCH without body</A>
<BR>
<A NAME="TOC23" HREF="manual.html#SEC23">2.3.5 Suspicious CASE/DEFAULT</A>
<BR>
<A NAME="TOC24" HREF="manual.html#SEC24">2.3.6 Possible miss of BREAK before CASE/DEFAULT</A>
<BR>
</UL>
</UL>
<A NAME="TOC25" HREF="manual.html#SEC25">3. Bugs detected by Jlint</A>
<BR>
<UL>
<A NAME="TOC26" HREF="manual.html#SEC26">3.1 Synchronization</A>
<BR>
<UL>
<A NAME="TOC27" HREF="manual.html#SEC27">3.1.1 Loop <VAR>id</VAR>: invocation of synchronized method <VAR>name</VAR> can cause deadlock</A>
<BR>
<A NAME="TOC28" HREF="manual.html#SEC28">3.1.2 Loop <VAR>LoopId/PathId</VAR>: invocation of method <VAR>name</VAR> forms the loop in class dependency graph</A>
<BR>
<A NAME="TOC29" HREF="manual.html#SEC29">3.1.3 Lock <VAR>a</VAR> is requested while holding lock <VAR>b</VAR>, with other thread holding <VAR>a</VAR> and requesting lock <VAR>b</VAR></A>
<BR>
<A NAME="TOC30" HREF="manual.html#SEC30">3.1.4 Method wait() can be invoked with monitor of other object locked</A>
<BR>
<A NAME="TOC31" HREF="manual.html#SEC31">3.1.5 Call sequence to method <VAR>name</VAR> can cause deadlock in wait()</A>
<BR>
<A NAME="TOC32" HREF="manual.html#SEC32">3.1.6 Synchronized method <VAR>name</VAR> is overridden by non-synchronized method of derived class <VAR>name</VAR></A>
<BR>
<A NAME="TOC33" HREF="manual.html#SEC33">3.1.7 Method <VAR>name</VAR> can be called from different threads and is not synchronized</A>
<BR>
<A NAME="TOC34" HREF="manual.html#SEC34">3.1.8 Field <VAR>name</VAR> of class</A>
<BR>
<A NAME="TOC35" HREF="manual.html#SEC35">3.1.9 Method <VAR>name</VAR> implementing 'Runnable' interface is not synchronized</A>
<BR>
<A NAME="TOC36" HREF="manual.html#SEC36">3.1.10 Value of lock <VAR>name</VAR> is changed outside synchronization or constructor</A>
<BR>
<A NAME="TOC37" HREF="manual.html#SEC37">3.1.11 Value of lock <VAR>name</VAR> is changed while (potentially) owning it</A>
<BR>
<A NAME="TOC38" HREF="manual.html#SEC38">3.1.12 Method <CODE><VAR>name</VAR>.wait()</CODE> is called without synchronizing on <VAR>name</VAR></A>
<BR>
</UL>
<A NAME="TOC39" HREF="manual.html#SEC39">3.2 Inheritance</A>
<BR>
<UL>
<A NAME="TOC40" HREF="manual.html#SEC40">3.2.1 Method <VAR>name</VAR> is not overridden by method with the same name of derived class <VAR>name</VAR></A>
<BR>
<A NAME="TOC41" HREF="manual.html#SEC41">3.2.2 Component <VAR>name</VAR> in class <VAR>name</VAR> shadows one in base class <VAR>name</VAR></A>
<BR>
<A NAME="TOC42" HREF="manual.html#SEC42">3.2.3 Local variable <VAR>name</VAR> shadows component of class <VAR>name</VAR></A>
<BR>
<A NAME="TOC43" HREF="manual.html#SEC43">3.2.4 Method <CODE>finalize()</CODE> doesn't call <CODE>super.finalize()</CODE></A>
<BR>
</UL>
<A NAME="TOC44" HREF="manual.html#SEC44">3.3 Data flow</A>
<BR>
<UL>
<A NAME="TOC45" HREF="manual.html#SEC45">3.3.1 Method <VAR>name</VAR> can be invoked with NULL as <VAR>number</VAR> parameter and this parameter is used without check for null</A>
<BR>
<A NAME="TOC46" HREF="manual.html#SEC46">3.3.2 Value of referenced variable <VAR>name</VAR> may be NULL</A>
<BR>
<A NAME="TOC47" HREF="manual.html#SEC47">3.3.3 NULL reference can be used</A>
<BR>
<A NAME="TOC48" HREF="manual.html#SEC48">3.3.4 Zero operand for operation</A>
<BR>
<A NAME="TOC49" HREF="manual.html#SEC49">3.3.5 Result of operation is always 0</A>
<BR>
<A NAME="TOC50" HREF="manual.html#SEC50">3.3.6 Shift with count <VAR>relation</VAR> than <VAR>integer</VAR></A>
<BR>
<A NAME="TOC51" HREF="manual.html#SEC51">3.3.7 Shift count range [<VAR>min,max</VAR>] is out of domain</A>
<BR>
<A NAME="TOC52" HREF="manual.html#SEC52">3.3.8 Range of expression value has no intersection with <VAR>target</VAR> type domain</A>
<BR>
<A NAME="TOC53" HREF="manual.html#SEC53">3.3.9 Data can be lost as a result of truncation to <VAR>type</VAR></A>
<BR>
<A NAME="TOC54" HREF="manual.html#SEC54">3.3.10 May be type cast is not correctly applied</A>
<BR>
<A NAME="TOC55" HREF="manual.html#SEC55">3.3.11 Comparison always produces the same result</A>
<BR>
<A NAME="TOC56" HREF="manual.html#SEC56">3.3.12 Compared operands can be equal only when both of them are 0</A>
<BR>
<A NAME="TOC57" HREF="manual.html#SEC57">3.3.13 Reminder always equal to the first operand</A>
<BR>
<A NAME="TOC58" HREF="manual.html#SEC58">3.3.14 Comparison of short with char</A>
<BR>
<A NAME="TOC59" HREF="manual.html#SEC59">3.3.15 Compare strings as object references</A>
<BR>
<A NAME="TOC60" HREF="manual.html#SEC60">3.3.16 Inequality comparison can be replaced with equality comparison</A>
<BR>
<A NAME="TOC61" HREF="manual.html#SEC61">3.3.17 Switch case constant <VAR>integer</VAR> can't be produced by switch expression</A>
<BR>
</UL>
</UL>
<A NAME="TOC62" HREF="manual.html#SEC62">4. Command line options</A>
<BR>
<UL>
<A NAME="TOC63" HREF="manual.html#SEC63">4.1 AntiC command line options</A>
<BR>
<A NAME="TOC64" HREF="manual.html#SEC64">4.2 Jlint command line options</A>
<BR>
<A NAME="TOC65" HREF="manual.html#SEC65">4.3 Jlint messages hierarchy</A>
<BR>
</UL>
<A NAME="TOC66" HREF="manual.html#SEC66">5. How to build and use Jlint and AntiC</A>
<BR>
<A NAME="TOC67" HREF="manual.html#SEC67">6. Release notes</A>
<BR>
</UL>
<HR SIZE=1>
<A NAME="SEC_OVERVIEW"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1>Short Table of Contents</H1>
<BLOCKQUOTE>
<A NAME="TOC1" HREF="manual.html#SEC1">1. Introduction</A>
<BR>
<A NAME="TOC2" HREF="manual.html#SEC2">2. Bugs detected by AntiC</A>
<BR>
<A NAME="TOC25" HREF="manual.html#SEC25">3. Bugs detected by Jlint</A>
<BR>
<A NAME="TOC62" HREF="manual.html#SEC62">4. Command line options</A>
<BR>
<A NAME="TOC66" HREF="manual.html#SEC66">5. How to build and use Jlint and AntiC</A>
<BR>
<A NAME="TOC67" HREF="manual.html#SEC67">6. Release notes</A>
<BR>

</BLOCKQUOTE>
<HR SIZE=1>
<A NAME="SEC_About"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1>About this document</H1>
This document was generated by <I>Cyrille Artho</I> on <I>January, 11  2011</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>
<P></P>  
The buttons in the navigation panels have the following meaning:
<P></P>
<table border = "1">
<TR>
<TH> Button </TH>
<TH> Name </TH>
<TH> Go to </TH>
<TH> From 1.2.3 go to</TH>
</TR>
<TR>
<TD ALIGN="CENTER">
 [ &lt; ] </TD>
<TD ALIGN="CENTER">
Back
</TD>
<TD>
previous section in reading order
</TD>
<TD>
1.2.2
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
 [ &gt; ] </TD>
<TD ALIGN="CENTER">
Forward
</TD>
<TD>
next section in reading order
</TD>
<TD>
1.2.4
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
 [ &lt;&lt; ] </TD>
<TD ALIGN="CENTER">
FastBack
</TD>
<TD>
previous or up-and-previous section 
</TD>
<TD>
1.1
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
 [ Up ] </TD>
<TD ALIGN="CENTER">
Up
</TD>
<TD>
up section
</TD>
<TD>
1.2
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
 [ &gt;&gt; ] </TD>
<TD ALIGN="CENTER">
FastForward
</TD>
<TD>
next or up-and-next section
</TD>
<TD>
1.3
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
 [Top] </TD>
<TD ALIGN="CENTER">
Top
</TD>
<TD>
cover (top) of document
</TD>
<TD>
 &nbsp; 
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
 [Contents] </TD>
<TD ALIGN="CENTER">
Contents
</TD>
<TD>
table of contents
</TD>
<TD>
 &nbsp; 
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
 [Index] </TD>
<TD ALIGN="CENTER">
Index
</TD>
<TD>
concept index
</TD>
<TD>
 &nbsp; 
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
 [ ? ] </TD>
<TD ALIGN="CENTER">
About
</TD>
<TD>
this page
</TD>
<TD>
 &nbsp; 
</TD>
</TR>
</TABLE>
<P></P>
where the <STRONG> Example </STRONG> assumes that the current position 
is at <STRONG> Subsubsection One-Two-Three </STRONG> of a document of 
the following structure:
<UL>
<LI> 1. Section One  </LI>
<UL>
<LI>1.1 Subsection One-One</LI>
<UL>
<LI> ... </LI>
</UL>
<LI>1.2 Subsection One-Two</LI>
<UL>
<LI>1.2.1 Subsubsection One-Two-One
</LI><LI>1.2.2 Subsubsection One-Two-Two
</LI><LI>1.2.3 Subsubsection One-Two-Three &nbsp; &nbsp; <STRONG>
&lt;== Current Position </STRONG>
</LI><LI>1.2.4 Subsubsection One-Two-Four
</LI></UL>
<LI>1.3 Subsection One-Three</LI>
<UL>
<LI> ... </LI>
</UL>
<LI>1.4 Subsection One-Four</LI>
</UL>
</UL>

<HR SIZE=1>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Cyrille Artho</I> on <I>January, 11  2011</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
